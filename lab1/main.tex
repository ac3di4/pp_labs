\documentclass[a4paper, 12pt]{article}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{geometry}
\usepackage{setspace}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{indentfirst}
\usepackage{titlesec}
\usepackage{pgfplots}
\usepackage{pgfplotstable}

\pgfplotsset{width=12cm, compat=1.18}
\newgeometry{left=1.5 cm, right=1.5cm, top=1.5cm, bottom=1.5cm}

\begin{document}


% ---------------------------------- Титульник ----------------------------------
\hypersetup{pageanchor=false}
\begin{titlepage}
 \begin{center}
  \vspace*{1cm}

  \Huge
  \textbf{Лабораторная работа №1}

  \vspace{0.5cm}
  \LARGE
  ``Введение в паралеллельные вычисления. Технолония OpenMP''

  \vspace{1.5cm}
  Выполнил студент группы Б20-505\\
  \textbf{Сорочан Илья}

  \vfill

  \Large
  Московский Инженерно-Физический Интститут\\
  Москва 2023

 \end{center}
\end{titlepage}


% ---------------------------------- Рабочая среда ----------------------------------

\section{Рабочая среда}

Технические характеристики (вывод \textit{inxi}):
\begin{verbatim}
CPU: 6-core AMD Ryzen 5 4500U with Radeon Graphics (-MCP-)
speed/min/max: 1396/1400/2375 MHz Kernel: 5.15.85-1-MANJARO x86_64 Up: 46m
Mem: 2689.5/7303.9 MiB (36.8%) Storage: 238.47 GiB (12.6% used) Procs: 238
Shell: Zsh inxi: 3.3.24
\end{verbatim}

Используемый компилятор:
\begin{verbatim}
gcc (GCC) 12.2.0
\end{verbatim}

Согласно \href{https://www.openmp.org/resources/openmp-compilers-tools/}{официальной документации} даная версия компилятора поддерживает \textit{OpenMP 5.0}

% ---------------------------------- Анализ алгоритма ----------------------------------

\section{Анализ алгоритма}

Данный алгоритм ищет максимум в массиве со случайно сгенерированными значениями. Длинна задается постоянной.\\
Временная сложность $O(\frac{count}{threads})$, где:
\begin{itemize}
 \item $count$ -- число элементов в массиве;
 \item $threads$ -- число используемых потоков.
\end{itemize}

\vspace{0.5cm}

Блок схема поиска максимума:\\
\includegraphics[scale=0.6]{res/flowchart.png}

\vspace{0.5cm}

При этом директива \textit{omp for} распределяет итерации цикла между потоками.
Если бы её не было, то благодаря \textit{omp parallel} поиск максимума в каждом потоке был бы произведен по всему массиву.

Директива \textit{omp parallel} задает несколько опций параллелизации:
\begin{itemize}
 \item \textit{num\_threads} - используемых потоков;
 \item \textit{shared} - общая для всех потоков память (переменные);
 \item \textit{reduction} - способ объединения локальных данных потоков после окончания параллельного промежутка. В данном случае берется максимальный среди них;
 \item \textit{default} - локальность перемнных по умолчанию. В данном случае по умолчанию все переменные локальные.
\end{itemize}
Без \textit{omp parallel} программа компилируется без ошибок, однако цикл выполняется одним потоком.


% ---------------------------------- Графики ----------------------------------

\section{Экспериментальные данные}

Во всех измерениях бралось 10 запусков на поток.

\vspace{0.3cm}

\begin{tikzpicture}
 \begin{axis}[
    xlabel={Число потоков},
    ylabel={Время (мс)},
    legend pos=north east,
  ]
  \addplot table [x=Threads, y=Worst (ms), col sep=comma] {data/data.csv};
  \addplot table [x=Threads, y=Best (ms), col sep=comma] {data/data.csv};
  \addplot table [x=Threads, y=Average (ms), col sep=comma] {data/data.csv};
  \legend{Худшее время, Лучшее время, Среднее время}
 \end{axis}
\end{tikzpicture}

\vspace{0.5cm}

Из графика видно, что в среднем многопоточная программа работает медленнее. Я могу выделить две основные причины.

Во-первых представленная задача проста в вычислительном плане. Вполне возможно, что инициализация работы с потоками занимает слишком много времени для такой тривиальной задачи.

Во-вторых оптимизации компилятора. Я провел повторные тесты с добавлением флага \textit{-O3}:

\vspace{0.3cm}

\begin{tikzpicture}
 \begin{axis}[
    xlabel={Число потоков},
    ylabel={Среднее время (мс)},
    legend pos=north east,
  ]
  \addplot table [x=Threads, y=Worst (ms), col sep=comma] {data/optimized.csv};
  \addplot table [x=Threads, y=Best (ms), col sep=comma] {data/optimized.csv};
  \addplot table [x=Threads, y=Average (ms), col sep=comma] {data/optimized.csv};
  \legend{Худшее время, Лучшее время, Среднее время}
 \end{axis}
\end{tikzpicture}

\vspace{0.3cm}

Прекрасно видно, что однопоточная программа лидирует с большим отрывом и причиной этому -- оптимизации компилятора.

Для сравнения вот среднее время с \textit{-O3} и без него:

\vspace{0.3cm}

\begin{tikzpicture}
 \begin{axis}[
    xlabel={Число потоков},
    ylabel={Среднее время (мс)},
    legend pos=north east,
  ]
  \addplot table [x=Threads, y=Average (ms), col sep=comma] {data/data.csv};
  \addplot table [x=Threads, y=Average (ms), col sep=comma] {data/optimized.csv};
  \legend{Без \textit{-O3}, C \textit{-O3}}
 \end{axis}
\end{tikzpicture}

\vspace{0.3cm}

Рассмотрим так же прирост, даваймый каждым числом процессоров относительно первого (берем среднее время):

\begin{tikzpicture}
 \begin{axis}[
    xlabel={Число потоков},
    ylabel={Прирост (\%)},
    ybar interval=0.7,
  ]
  \addplot table [x=Threads, y=Average (ms), col sep=comma] {data/compare.csv};
 \end{axis}
\end{tikzpicture}

% ---------------------------------- Заключение ----------------------------------

\section{Заключение}
В данной работе было исследовано ускорение, получаемое при использовании многопоточности в задании о нахождении максимума. Была усовершенствована предоставленная программа и написан специальный скрипт, собирающие данные о нескольких запусках этой программы в один файл, попутно её перекомпилируя.

В ходе работы было выяснено, что в данной задаче применение многопоточности лишь замедлит программу. С уверенностью можно сказать, что частью причины таких результатов являются оптимизации, производимые компилятором.

С другой стороны стоит отметить, что вычислительная сложность программы низка, а соответсвенно инициализация потоков не выгодна.

\appendix

\titleformat{\section}[display]
  {\normalfont\Large\bfseries}
  {\centering Приложение\ \thesection\\}
  {0pt}{\Large\centering}
\renewcommand{\thesection}{\Asbuk{section}}

\section{Использованные программные коды}

Оригинальный предоставленный код:
\lstinputlisting[language=C, basicstyle=\tiny]{src/original.c}
\vspace{0.5cm}

Код без многопоточности:
\lstinputlisting[language=C, basicstyle=\small]{src/main.c}
\vspace{0.5cm}

Доработанный код:
\lstinputlisting[language=C, basicstyle=\tiny]{src/threaded.c}
\vspace{0.5cm}

Для сборки данных использовался следующий скрипт:
\lstinputlisting[language=Python, basicstyle=\scriptsize]{src/main.py}
\vspace{0.5cm}

Для вычисления относительного прироста производительности использовался следующий скрипт:
\lstinputlisting[language=Python, basicstyle=\footnotesize]{src/compare.py}
\vspace{0.5cm}

\section{Таблицы с теоритическими и практическими результатами}

Таблица без оптимизаций:

\vspace{0.3cm}

\pgfplotstabletypeset[
 col sep=comma,
 columns={Threads,Worst (ms),Best (ms),Average (ms)},
]{data/data.csv}

\vspace{0.5cm}

Таблица с оптимизациями:

\vspace{0.3cm}

\pgfplotstabletypeset[
 col sep=comma,
 columns={Threads,Worst (ms),Best (ms),Average (ms)},
]{data/optimized.csv}

\vspace{0.5cm}

Таблица сравнений:

\vspace{0.3cm}

\pgfplotstabletypeset[
 col sep=comma,
 columns={Threads,Average (ms)},
]{data/compare.csv}


\end{document}
