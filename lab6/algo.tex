\section{Реализация сортировки Шелла с использованием \textit{MPI}}

\subsection{Параллелизация алгоритма}

Цикл по различным $d$ будет выполнятся в главном процессе.
При этом на каждой своей итерации он будет рассылать фрагменты массива другим потокам.
Есть два способа делать это:
\begin{itemize}
    \item Брать последовательные фрагменты массива;
    \item Брать $d$-е элементы относительно i.
\end{itemize}

\subsection{Последовательные фрагменты}

Суть данного способа -- разделить массив на (почти) равные части между процессами и произвести сортировку на каждом.
У данного способа есть 2 существенные проблемы:
\begin{enumerate}
    \item Размер массива может ровно не делиться на количество процессов;
    \item Фрагменты массива при получении главным потоком нужно дополнительно отсортировать. Простейшая сортировка слиянием.
\end{enumerate}

Первая проблема нивелируется тем, что если число процессов невелико, то оставшиеся элементы можно отдать одному из них не потеряв сильно в производительности.

Вторая проблема гораздо существеннее. 
После параллельной сортировки сами фрагменты отсортированы, но не относительно друг-друга.
В качестве решения можно произвести сортировку слиянием.

Её тоже можно сделать параллельно, но я затрудняюсь это реализовать.

\subsection{$d$-е элементы}

С помощью векторного типа \textit{MPI} можно передавать $d$-е элементы.
Тогда сортировка в под-процессах превращается в обычную сортировку слиянием.

Однако этот подход так же не лишен проблем:
\begin{itemize}
    \item Количество и длинна под-векторов, на которые необходимо разбивать меняется каждую итерацию внешнего цикла по $d$ из-за чего произвести равномерное распределение сложнее;
    \item Если одному процессу передается несколько под-векторов, то не ясно в каком порядке он их вернет.
\end{itemize}

Вторую проблему можно решить путем задания определенного порядка отправления и возврата.

Первая проблема даже при хорошем распределении останется проблемой.
К тому же пересылка большого объема данных звучит не очень хорошо.

\subsection{Выбранный алгоритм}

Учитывая вышеописанные минусы различных подходов я решил остановится на первом методе.

По своей сути второй метод совершает больше пересылок, когда как первый не использует все процессы в конце.

\subsection{Исходный код}

Полный исходный код предоставлен в приложении А.